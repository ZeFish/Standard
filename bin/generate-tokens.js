#!/usr/bin/env node

/**
 * Design Token Generator
 * 
 * Converts YAML design tokens from standard.config.yml into CSS custom properties.
 * Generates framework/styles/_standard-01-token-generated.scss
 * 
 * @author Francis Fontaine
 * @since 1.2.0
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import yaml from "js-yaml";
import Logger from "../core/logger.js";

const logger = Logger({ scope: "Tokens" });

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = process.cwd();

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG_PATH = path.join(projectRoot, "standard.config.yml");
const OUTPUT_PATH = path.join(
    projectRoot,
    "framework/styles/_standard-01-token-generated.scss"
);

// ============================================================================
// TOKEN CONVERSION
// ============================================================================

/**
 * Convert a nested object path to a CSS custom property name
 * @param {string[]} path - Array of keys representing the path
 * @returns {string} CSS variable name (e.g., --typography-body-font)
 */
function pathToCssVar(path) {
    return `--${path.join("-")}`;
}

/**
 * Format a value for CSS output
 * Preserves quotes, calc expressions, and other CSS-specific syntax
 * @param {*} value - The value to format
 * @returns {string} Formatted CSS value
 */
function formatCssValue(value) {
    if (typeof value === "string") {
        // Already has quotes or is a CSS function/keyword - return as-is
        if (
            value.startsWith('"') ||
            value.startsWith("'") ||
            value.startsWith("var(") ||
            value.startsWith("calc(") ||
            value.startsWith("color-mix(") ||
            value.match(/^[0-9.]+[a-z%]*$/i) || // Numbers with units
            value.match(/^#[0-9a-f]{3,8}$/i) // Hex colors
        ) {
            return value;
        }
        // Otherwise, wrap in quotes
        return `"${value}"`;
    }
    if (typeof value === "number") {
        return value.toString();
    }
    if (typeof value === "boolean") {
        return value ? "true" : "false";
    }
    if (Array.isArray(value)) {
        return value.map(formatCssValue).join(", ");
    }
    return String(value);
}

/**
 * Recursively convert a nested object to CSS custom properties
 * @param {object} obj - The object to convert
 * @param {string[]} path - Current path in the object hierarchy
 * @returns {string[]} Array of CSS property declarations
 */
function objectToCssVars(obj, path = []) {
    const declarations = [];

    for (const [key, value] of Object.entries(obj)) {
        const currentPath = [...path, key];

        if (value && typeof value === "object" && !Array.isArray(value)) {
            // Recursively process nested objects
            declarations.push(...objectToCssVars(value, currentPath));
        } else {
            // Generate CSS custom property
            const cssVar = pathToCssVar(currentPath);
            const cssValue = formatCssValue(value);
            declarations.push(`  ${cssVar}: ${cssValue};`);
        }
    }

    return declarations;
}

/**
 * Generate SCSS file content from design tokens
 * @param {object} designTokens - The design section from config
 * @returns {string} Complete SCSS file content
 */
function generateScss(designTokens) {
    const timestamp = new Date().toISOString();
    const declarations = objectToCssVars(designTokens);

    return `/**
 * AUTO-GENERATED DESIGN TOKENS
 * 
 * This file is automatically generated from standard.config.yml
 * DO NOT EDIT MANUALLY - Changes will be overwritten
 * 
 * Generated: ${timestamp}
 * Source: standard.config.yml (design section)
 */

:root {
${declarations.join("\n")}
}
`;
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

export async function generateTokens() {
    try {
        // Check if config file exists
        if (!fs.existsSync(CONFIG_PATH)) {
            logger.warn("No standard.config.yml found. Skipping token generation.");
            return;
        }

        // Load and parse YAML
        const configContent = fs.readFileSync(CONFIG_PATH, "utf-8");
        const config = yaml.load(configContent);

        // Extract design tokens
        const designTokens = config.design;

        if (!designTokens || Object.keys(designTokens).length === 0) {
            logger.warn("No design tokens found in standard.config.yml");
            return;
        }

        // Generate SCSS content
        const scssContent = generateScss(designTokens);

        // Ensure output directory exists
        const outputDir = path.dirname(OUTPUT_PATH);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        // Write to file
        fs.writeFileSync(OUTPUT_PATH, scssContent, "utf-8");

        const tokenCount = scssContent.split("\n").filter((line) =>
            line.trim().startsWith("--")
        ).length;

        logger.success(
            `Generated ${tokenCount} design tokens â†’ framework/styles/_standard-01-token-generated.scss`
        );
    } catch (error) {
        logger.error(`Token generation failed: ${error.message}`);
        throw error;
    }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    await generateTokens();
}
